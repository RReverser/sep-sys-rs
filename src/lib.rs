/* automatically generated by rust-bindgen 0.71.1 */

#![no_std]
#![allow(non_camel_case_types)]

pub const SEP_TBYTE: ::core::ffi::c_int = 11;
pub const SEP_TINT: ::core::ffi::c_int = 31;
pub const SEP_TFLOAT: ::core::ffi::c_int = 42;
pub const SEP_TDOUBLE: ::core::ffi::c_int = 82;
pub const SEP_OBJ_MERGED: ::core::ffi::c_short = 1;
pub const SEP_OBJ_TRUNC: ::core::ffi::c_short = 2;
pub const SEP_OBJ_DOVERFLOW: ::core::ffi::c_short = 4;
pub const SEP_OBJ_SINGU: ::core::ffi::c_short = 8;
pub const SEP_APER_TRUNC: ::core::ffi::c_short = 16;
pub const SEP_APER_HASMASKED: ::core::ffi::c_short = 32;
pub const SEP_APER_ALLMASKED: ::core::ffi::c_short = 64;
pub const SEP_APER_NONPOSITIVE: ::core::ffi::c_short = 128;
pub const SEP_NOISE_NONE: ::core::ffi::c_short = 0;
pub const SEP_NOISE_STDDEV: ::core::ffi::c_short = 1;
pub const SEP_NOISE_VAR: ::core::ffi::c_short = 2;
pub const SEP_MASK_IGNORE: ::core::ffi::c_short = 4;
pub const SEP_THRESH_REL: ::core::ffi::c_int = 0;
pub const SEP_THRESH_ABS: ::core::ffi::c_int = 1;
pub const SEP_FILTER_CONV: ::core::ffi::c_int = 0;
pub const SEP_FILTER_MATCHED: ::core::ffi::c_int = 1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sep_image {
    pub data: *const ::core::ffi::c_void,
    pub noise: *const ::core::ffi::c_void,
    pub mask: *const ::core::ffi::c_void,
    pub segmap: *const ::core::ffi::c_void,
    pub dtype: ::core::ffi::c_int,
    pub ndtype: ::core::ffi::c_int,
    pub mdtype: ::core::ffi::c_int,
    pub sdtype: ::core::ffi::c_int,
    pub segids: *mut i64,
    pub idcounts: *mut i64,
    pub numids: i64,
    pub w: i64,
    pub h: i64,
    pub noiseval: f64,
    pub noise_type: ::core::ffi::c_short,
    pub gain: f64,
    pub maskthresh: f64,
}
impl Default for sep_image {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sep_bkg {
    pub w: i64,
    pub h: i64,
    pub bw: i64,
    pub bh: i64,
    pub nx: i64,
    pub ny: i64,
    pub n: i64,
    pub global: f32,
    pub globalrms: f32,
    pub back: *mut f32,
    pub dback: *mut f32,
    pub sigma: *mut f32,
    pub dsigma: *mut f32,
}
impl Default for sep_bkg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sep_catalog {
    pub nobj: ::core::ffi::c_int,
    pub thresh: *mut f32,
    pub npix: *mut i64,
    pub tnpix: *mut i64,
    pub xmin: *mut i64,
    pub xmax: *mut i64,
    pub ymin: *mut i64,
    pub ymax: *mut i64,
    pub x: *mut f64,
    pub y: *mut f64,
    pub x2: *mut f64,
    pub y2: *mut f64,
    pub xy: *mut f64,
    pub errx2: *mut f64,
    pub erry2: *mut f64,
    pub errxy: *mut f64,
    pub a: *mut f32,
    pub b: *mut f32,
    pub theta: *mut f32,
    pub cxx: *mut f32,
    pub cyy: *mut f32,
    pub cxy: *mut f32,
    pub cflux: *mut f32,
    pub flux: *mut f32,
    pub cpeak: *mut f32,
    pub peak: *mut f32,
    pub xcpeak: *mut i64,
    pub ycpeak: *mut i64,
    pub xpeak: *mut i64,
    pub ypeak: *mut i64,
    pub flag: *mut ::core::ffi::c_short,
    pub pix: *mut *mut i64,
    pub objectspix: *mut i64,
}
impl Default for sep_catalog {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn sep_background(
        image: *const sep_image,
        bw: i64,
        bh: i64,
        fw: i64,
        fh: i64,
        fthresh: f64,
        bkg: *mut *mut sep_bkg,
    ) -> ::core::ffi::c_int;
    pub fn sep_bkg_global(bkg: *const sep_bkg) -> f32;
    pub fn sep_bkg_globalrms(bkg: *const sep_bkg) -> f32;
    pub fn sep_bkg_pix(bkg: *const sep_bkg, x: i64, y: i64) -> f32;
    pub fn sep_bkg_line(
        bkg: *const sep_bkg,
        y: i64,
        line: *mut ::core::ffi::c_void,
        dtype: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sep_bkg_subline(
        bkg: *const sep_bkg,
        y: i64,
        line: *mut ::core::ffi::c_void,
        dtype: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sep_bkg_rmsline(
        bkg: *const sep_bkg,
        y: i64,
        line: *mut ::core::ffi::c_void,
        dtype: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sep_bkg_array(
        bkg: *const sep_bkg,
        arr: *mut ::core::ffi::c_void,
        dtype: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sep_bkg_subarray(
        bkg: *const sep_bkg,
        arr: *mut ::core::ffi::c_void,
        dtype: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sep_bkg_rmsarray(
        bkg: *const sep_bkg,
        arr: *mut ::core::ffi::c_void,
        dtype: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn sep_bkg_free(bkg: *mut sep_bkg);
    pub fn sep_extract(
        image: *const sep_image,
        thresh: f32,
        thresh_type: ::core::ffi::c_int,
        minarea: ::core::ffi::c_int,
        conv: *const f32,
        convw: i64,
        convh: i64,
        filter_type: ::core::ffi::c_int,
        deblend_nthresh: ::core::ffi::c_int,
        deblend_cont: f64,
        clean_flag: ::core::ffi::c_int,
        clean_param: f64,
        catalog: *mut *mut sep_catalog,
    ) -> ::core::ffi::c_int;
    pub fn sep_set_extract_pixstack(val: usize);
    pub fn sep_get_extract_pixstack() -> usize;
    pub fn sep_set_sub_object_limit(val: ::core::ffi::c_int);
    pub fn sep_get_sub_object_limit() -> ::core::ffi::c_int;
    pub fn sep_catalog_free(catalog: *mut sep_catalog);
    pub fn sep_sum_circle(
        image: *const sep_image,
        x: f64,
        y: f64,
        r: f64,
        id: ::core::ffi::c_int,
        subpix: ::core::ffi::c_int,
        inflags: ::core::ffi::c_short,
        sum: *mut f64,
        sumerr: *mut f64,
        area: *mut f64,
        flag: *mut ::core::ffi::c_short,
    ) -> ::core::ffi::c_int;
    pub fn sep_sum_circann(
        image: *const sep_image,
        x: f64,
        y: f64,
        rin: f64,
        rout: f64,
        id: ::core::ffi::c_int,
        subpix: ::core::ffi::c_int,
        inflags: ::core::ffi::c_short,
        sum: *mut f64,
        sumerr: *mut f64,
        area: *mut f64,
        flag: *mut ::core::ffi::c_short,
    ) -> ::core::ffi::c_int;
    pub fn sep_sum_ellipse(
        image: *const sep_image,
        x: f64,
        y: f64,
        a: f64,
        b: f64,
        theta: f64,
        r: f64,
        id: ::core::ffi::c_int,
        subpix: ::core::ffi::c_int,
        inflags: ::core::ffi::c_short,
        sum: *mut f64,
        sumerr: *mut f64,
        area: *mut f64,
        flag: *mut ::core::ffi::c_short,
    ) -> ::core::ffi::c_int;
    pub fn sep_sum_ellipann(
        image: *const sep_image,
        x: f64,
        y: f64,
        a: f64,
        b: f64,
        theta: f64,
        rin: f64,
        rout: f64,
        id: ::core::ffi::c_int,
        subpix: ::core::ffi::c_int,
        inflags: ::core::ffi::c_short,
        sum: *mut f64,
        sumerr: *mut f64,
        area: *mut f64,
        flag: *mut ::core::ffi::c_short,
    ) -> ::core::ffi::c_int;
    pub fn sep_sum_circann_multi(
        im: *const sep_image,
        x: f64,
        y: f64,
        rmax: f64,
        n: i64,
        id: ::core::ffi::c_int,
        subpix: ::core::ffi::c_int,
        inflag: ::core::ffi::c_short,
        sum: *mut f64,
        sumvar: *mut f64,
        area: *mut f64,
        maskarea: *mut f64,
        flag: *mut ::core::ffi::c_short,
    ) -> ::core::ffi::c_int;
    pub fn sep_flux_radius(
        im: *const sep_image,
        x: f64,
        y: f64,
        rmax: f64,
        id: ::core::ffi::c_int,
        subpix: ::core::ffi::c_int,
        inflag: ::core::ffi::c_short,
        fluxtot: *const f64,
        fluxfrac: *const f64,
        n: i64,
        r: *mut f64,
        flag: *mut ::core::ffi::c_short,
    ) -> ::core::ffi::c_int;
    pub fn sep_kron_radius(
        im: *const sep_image,
        x: f64,
        y: f64,
        cxx: f64,
        cyy: f64,
        cxy: f64,
        r: f64,
        id: ::core::ffi::c_int,
        kronrad: *mut f64,
        flag: *mut ::core::ffi::c_short,
    ) -> ::core::ffi::c_int;
    pub fn sep_windowed(
        im: *const sep_image,
        x: f64,
        y: f64,
        sig: f64,
        subpix: ::core::ffi::c_int,
        inflag: ::core::ffi::c_short,
        xout: *mut f64,
        yout: *mut f64,
        niter: *mut ::core::ffi::c_int,
        flag: *mut ::core::ffi::c_short,
    ) -> ::core::ffi::c_int;
    pub fn sep_set_ellipse(
        arr: *mut ::core::ffi::c_uchar,
        w: i64,
        h: i64,
        x: f64,
        y: f64,
        cxx: f64,
        cyy: f64,
        cxy: f64,
        r: f64,
        val: ::core::ffi::c_uchar,
    );
    pub fn sep_ellipse_axes(
        cxx: f64,
        cyy: f64,
        cxy: f64,
        a: *mut f64,
        b: *mut f64,
        theta: *mut f64,
    ) -> ::core::ffi::c_int;
    pub fn sep_ellipse_coeffs(
        a: f64,
        b: f64,
        theta: f64,
        cxx: *mut f64,
        cyy: *mut f64,
        cxy: *mut f64,
    );
    pub static sep_version_string: *const ::core::ffi::c_char;
    pub fn sep_get_errmsg(status: ::core::ffi::c_int, errtext: *mut ::core::ffi::c_char);
    pub fn sep_get_errdetail(errtext: *mut ::core::ffi::c_char);
}
